### [1415. The k-th Lexicographical String of All Happy Strings of Length n](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/)
#### Brute Force
```Typescript
function getHappyString(n: number, k: number): string {

  const abc = ['a', 'b', 'c']; 
  function helper(list: string[]): string[] {

    if (!list.length) return abc;
    
    const newList = [];
    for (const pref of list) {
      for (const ch of abc) {
        if (pref.at(-1) !== ch) {
          newList.push(pref + ch);
        }
      }
    }
    return newList;
  }

  let list = [];
  while (n) {
    list = helper(list);
    n--;
  }
  return list[k - 1] ?? '';
};
```
#### Clean Code
```Typescript
function getHappyString(n: number, k: number): string {
  const chars = ['a', 'b', 'c'];

  // Build prefix list for happy strings
  let happyStrings: string[] = [''];

  for (let i = 0; i < n; i++) {
    const nextLevel: string[] = [];
    for (const prefix of happyStrings) {
      for (const ch of chars) {
        if (prefix === '' || prefix.at(-1) !== ch) {
          nextLevel.push(prefix + ch);
        }
      }
    }
    happyStrings = nextLevel;
  }

  return happyStrings[k - 1] ?? '';
}
```
```Typescript
function getHappyString(n: number, k: number): string {
  const characters: string[] = ['a', 'b', 'c'];

  // Generates the next set of happy strings from the previous list
  function generateNext(prevStrings: string[]): string[] {
    // Base case: if the list is empty, start with single characters
    if (prevStrings.length === 0) {
      return characters;
    }

    const nextStrings: string[] = [];
    for (const str of prevStrings) {
      for (const char of characters) {
        // Append the character only if it differs from the last character
        if (str.at(-1) !== char) {
          nextStrings.push(str + char);
        }
      }
    }
    return nextStrings;
  }

  let happyStrings: string[] = [];
  while (n > 0) {
    happyStrings = generateNext(happyStrings);
    n--;
  }
  return happyStrings[k - 1] ?? ''; // Return k-th string or empty string if k is out of bounds
}
```
```Typescript
/**
 * Finds the k-th lexicographically smallest happy string of length n.
 * A happy string is a string of 'a', 'b', and 'c' where no two adjacent characters are the same.
 */
function getHappyString(n: number, k: number): string {
  const chars = ['a', 'b', 'c'];
  let happyStrings: string[] = [];

  /**
   * Generates all happy strings of a given length recursively.
   */
  function generateHappyStrings(currentString: string, length: number): void {
    // If the current string has reached the desired length, add it to the list.
    if (currentString.length === length) {
      happyStrings.push(currentString);
      return;
    }

    // Iterate through the characters to build the next valid happy string.
    for (const char of chars) {
      const lastChar = currentString.at(-1);

      // Only append the character if it's different from the last one.
      if (lastChar !== char) {
        generateHappyStrings(currentString + char, length);
      }
    }
  }

  // Start the generation process for each initial character.
  for (const char of chars) {
    generateHappyStrings(char, n);
  }

  // Return the k-th happy string, or an empty string if it doesn't exist.
  return happyStrings[k - 1] || '';
}
```
