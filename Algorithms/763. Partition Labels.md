### [763. Partition Labels](https://leetcode.com/problems/partition-labels)
#### Brute Force
```Typescript
function partitionLabels(s: string): number[] {
    const seen = new Set<string>();
    const partitions: [number, number][] = [[0, 0]];

    for (const char of s) {
        if (!seen.has(char)) {
            seen.add(char);
            const firstIndex = s.indexOf(char);
            const lastIndex = s.lastIndexOf(char);
            const lastPartition = partitions[partitions.length - 1];

            if (lastPartition[1] < firstIndex) {
                partitions.push([firstIndex, lastIndex]); // Start new partition
            } else {
                lastPartition[1] = Math.max(lastPartition[1], lastIndex); // Extend current partition
            }
        }
    }

    return partitions.map(([start, end]) => end - start + 1);
}
```
#### Clean Code
```Typescript
function partitionLabels(s: string): number[] {
  // Map each character to its last occurrence.
  const lastIndex: Record<string, number> = {};
  for (let i = 0; i < s.length; i++) {
    lastIndex[s[i]] = i;
  }

  const result: number[] = [];
  let start = 0, end = 0;

  for (let i = 0; i < s.length; i++) {
    end = Math.max(end, lastIndex[s[i]]);
    if (i === end) {
      result.push(end - start + 1);
      start = i + 1;
    }
  }

  return result;
}

```
```Python3
def partition_labels(s: str) -> list[int]:
    # Dictionary to store the last occurrence index of each character
    last_index = {}
    
    # Find last occurrence of each character
    for i, char in enumerate(s):
        last_index[char] = i
    
    result = []
    start = 0
    end = 0
    
    # Iterate through string to find partitions
    for i, char in enumerate(s):
        # Update end to be the max of current end and last index of current char
        end = max(end, last_index[char])
        
        # If we've reached the end of a partition
        if i == end:
            result.append(end - start + 1)
            start = i + 1
    
    return result
```
